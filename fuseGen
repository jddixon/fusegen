#!/usr/bin/python3
#
# ~/dev/py/fusegen/fuseGen

import errno, os, sys, shutil, time
from argparse  import ArgumentParser
from fusegen   import *

# attributes of fuse operations

DEPRECATED          = 0x00000001
RETURNS_STATUS      = 0x00000002
CHECK_ERR_AND_FLIP  = 0x00000004
FULL_PATH           = 0x00000008
DOUBLE_FULL_PATH    = 0x00000010
LOGGING_ENTRY       = 0x00000020
LOGGING_STAT        = 0x00000040
LOGGING_STATVFS     = 0x00000080
HAS_LINK_FILE       = 0x00000100
LOGGING_FI          = 0x00000200
SYSCALL_RET_FD      = 0x00000400
SET_FH_FROM_FD      = 0x00000800
SYSCALL_FI_PARAM1   = 0x00001000

CHK_DEF_XATTR       = 0x10000000

def setOpAttrs():
    """
    Return a map from fuse op names to attributes
    """
    opAttrs = {}
    for name in OP_NAMES:
        attrs = 0
        if name in ['symlink',]:
            attrs |= HAS_LINK_FILE

        if name == 'getdir':
            attrs |= DEPRECATED

        if name != 'init' and name != 'destroy':
            attrs |= RETURNS_STATUS

        if name in ['rename','link',]:
            attrs |= DOUBLE_FULL_PATH

        if name not in ['symlink',
                        'read', 'write', 'flush', 'release', 'fsync',
                        'readdir', 'releasedir','fsyncdir', 'init',
                        'destroy', 'ftruncate', 'fgetattr']:
            attrs |= FULL_PATH

        if name not in [ 'destroy', 'flush', 'fsyncdir',
                'init', 'mknod', 'readdir', ]:
            attrs |= CHECK_ERR_AND_FLIP

        if name in ['setxattr', 'getxattr', 'listxattr', 'removexattr',]:
            attrs |= CHK_DEF_XATTR

        # XXX THIS USED TO BE 'else'
        attrs |= LOGGING_ENTRY

        if name in ['create', 'fgetattr', 'flush', 'fsync', 'fsyncdir',
                'ftruncate',
                'opendir', 'open', 'readdir', 'read', 'releasedir',
                'release', 'write',]:
            attrs |= LOGGING_FI

        if name in ['create', 'open',  ]:
            attrs |= SET_FH_FROM_FD

        if name in ['fgetattr', 'fsync', 'opendir', 'read', 'releasedir', 'release', 'ftruncate', 'write']:
            attrs |= SYSCALL_FI_PARAM1

        if name in ['getattr', 'fgetattr',]:
            attrs |= LOGGING_STAT
        elif name == 'statfs':
            attrs |= LOGGING_STATVFS

        if name in ['create', 'open',]:
            attrs |= SYSCALL_RET_FD

        opAttrs[name] = attrs
    return opAttrs

def makedir_p(path, mode):
    # XXX SLOPPY: doesn't handle case where mode is wrong
    # XXX MISLEADING: the name suggests it creates missing subdirs
    try:
        os.mkdir(path, mode)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise e
        pass

def makeFusePkg(args):
    acPrereq        = args.acPrereq
    emailAddr       = args.emailAddr
    force           = args.force
    lcName          = args.lcName
    myDate          = args.myDate
    myVersion       = args.myVersion
    pathToPkg       = args.pathToPkg    # target package directory
    pkgName         = args.pkgName
    prefix          = pkgName + '_'     # XXX FORCES UNDERSCORE
    testing         = args.testing
    ucName          = args.ucName
    verbose         = args.verbose

    # if -force and pathToPkg exists, delete it ---------------------
    if force and os.path.exists(pathToPkg):
        shutil.rmtree(pathToPkg)

    # create directories --------------------------------------------
    os.mkdir(pathToPkg, 0o755)

    mountPoint      = os.path.join('workdir', 'mountPoint')
    rootDir         = os.path.join('workdir', 'rootdir')
    makeFileSubDirs = ['doc', 'examples', 'man', 'scripts', 'src', 'tests',]
    otherSubDirs    = ['bin', 'config', 'ghpDoc', 'm4', 'workdir',
                        mountPoint, rootDir, ]
    subDirs         = makeFileSubDirs + otherSubDirs
    for dir in subDirs:
        pathToSubDir = os.path.join(pathToPkg, dir)
        makedir_p(pathToSubDir, 0o755)

    # ===============================================================
    # TOP LEVEL FILES
    # ===============================================================

    # copy over fusgegen/src files  ---------------------------------
    def copyFromSrc(name, executable=False, topLevel=True):
        """ copy a file from py/fusegen/src/ to the top level package dir """
        src  = os.path.join('src', name)
        if topLevel:
            dest = os.path.join(pathToPkg, name)
        else:
            dest = os.path.join(pathToPkg, os.path.join('src', name))
        with open(src, 'r') as a:
            text = a.read()
            with open(dest,'w') as b:
                b.write(text)
            if executable:
                os.chmod(dest, 0o744)
            else:
                os.chmod(dest, 0o644)

    # install-sh removed from both lists 2015-02-22
    for x in ['autogen.sh', 'config.guess', 'config.sub', 'COPYING',
            'COPYING.LIB', 'COPYING.AUTOCONF.EXCEPTION',
            'README.licenses',]:
        copyFromSrc(x, x in ['autogen.sh', ])
    for x in ['fuse.h', 'fuse_common.h', 'fuse_opt.h', ]:
        copyFromSrc(x, False, False)

    # write CHANGES -------------------------------------------------
    chgFile = os.path.join(pathToPkg, 'CHANGES')
    with open(chgFile, 'w', 0o644) as f:
        f.write("~/dev/c/%s/CHANGES\n\n" % pkgName)
        f.write("v%s\n" % myVersion)
        f.write("    %s\n" % myDate)
        f.write("        *\n")

    # write configure.ac --------------------------------------------
    configFile = os.path.join(pathToPkg, 'configure.ac')
    configText = """#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.

AC_PREREQ([{0:s}])
AC_INIT([{1:s}], [{2:s}], [{3:s}])
AC_CONFIG_MACRO_DIR([m4])
AC_CONFIG_AUX_DIR([config])
LT_INIT
AM_INIT_AUTOMAKE
AC_CONFIG_SRCDIR([src/{1:s}.c])
AC_CONFIG_HEADERS([src/config.h])

# Programs
AC_PROG_CC

# Header files.
AC_CHECK_HEADERS([fcntl.h limits.h stdlib.h string.h sys/statvfs.h unistd.h utime.h sys/xattr.h])

# FUSE development environment
PKG_CHECK_MODULES(FUSE, fuse)

# Necessary typedefs and structures
AC_TYPE_MODE_T
AC_TYPE_OFF_T
AC_TYPE_PID_T
AC_TYPE_SIZE_T
AC_TYPE_UID_T
AC_TYPE_UINT64_T
AC_STRUCT_ST_BLOCKS
AC_CHECK_MEMBERS([struct stat.st_blksize])
AC_CHECK_MEMBERS([struct stat.st_rdev])

# Necessary library functions.
AC_FUNC_CHOWN
AC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK
AC_FUNC_MALLOC

AC_CHECK_FUNCS([fdatasync ftruncate mkdir mkfifo realpath rmdir strerror utime])

AC_CONFIG_FILES([Makefile src/Makefile])
AC_OUTPUT
""".format(acPrereq, pkgName, myDate, emailAddr)
    with open(configFile, 'w', 0o644) as f:
        f.write(configText)

    # write Makefile.am  --------------------------------------------
    # XXX The EXTRA_DIST line seems senseless, as we copy it in.
    makeAMFile = os.path.join(pathToPkg, 'Makefile.am')
    content = """
ACLOCAL_AMFLAGS = -I m4
EXTRA_DIST = autogen.sh
SUBDIRS = src

# <ATTRIBUTION>
#
# Make it impossible to install the fuse file system. It must never be run
# as root, because that causes critical security risks.
install install-data install-exec uninstall installdirs check installcheck:
	echo This package must never be installed.

install-dvi install-info install-ps install-pdf dvi pdf ps info :
	echo This package must never be installed.
"""
    with open(makeAMFile, 'w', 0o644) as f:
        f.write(content)

    # write Makefile.in  --------------------------------------------
    # XXX This bit of silliness handles aclocal's requirement that
    # the file exist before we create it
    makeInFile = os.path.join(pathToPkg, os.path.join('src','Makefile.in'))
    content = """
"""
    with open(makeInFile, 'w', 0o644) as f:
        f.write(content)

    # write TODO ----------------------------------------------------
    todoFile = os.path.join(pathToPkg, 'TODO')
    with open(todoFile, 'w', 0o644) as f:
        f.write("~/dev/c/%s/TODO\n\n" % pkgName)
        f.write("%s\n" % myDate)
        f.write("    *\n")

    # ===============================================================
    # bin/ FILE GENERATION
    # ===============================================================

    # write bin/mountNAME
    pathToBin = os.path.join(pathToPkg, 'bin')
    pathToCmd = os.path.join(pathToBin, 'mount' + ucName)
    with open(pathToCmd, 'w') as f:
        f.write("cd %s\n" % pathToPkg)
        f.write("src/%s workdir/rootdir workdir/mountPoint\n" % pkgName)
    os.chmod(pathToCmd, 0o744)

    # write bin/umountNAME
    pathToCmd = os.path.join(pathToBin, 'umount' + ucName)
    with open(pathToCmd, 'w') as f:
        f.write("cd %s\n" % pathToPkg)
        f.write("fusermount -uz workdir/mountPoint\n")
    os.chmod(pathToCmd, 0o744)

    # ===============================================================
    # src/ FILE GENERATION
    # ===============================================================

    pathToSrc = os.path.join(pathToPkg, 'src')

    # fuse_version.h ------------------------------------------------

    fuseVersionFile = os.path.join(pathToSrc, 'fuse_version.h')
    content = """/** fuse_version.h */

#ifndef _FUSE_VERSION_H_
#define _FUSE_VERSION_H_

#define FUSE_USE_VERSION 26

#endif
"""

    with open(fuseVersionFile, 'w') as f:
        f.write(content)

    # src/Makefile.am -----------------------------------------------
    makeAMFile = os.path.join(pathToSrc, 'Makefile.am')
    content = """
bin_PROGRAMS = {0:s}
{1:s}SOURCES = {0:s}.c fuse.h fuse_version.h {0:s}.h util.c
AM_CFLAGS = @FUSE_CFLAGS@
LDADD = @FUSE_LIBS@
""".format(pkgName, prefix)

    with open(makeAMFile, 'w', 0o644) as f:
        f.write(content)

    # generate main.inc ---------------------------------------------
    content = """/** main.inc */

void {0:s}Usage()
{{
    fprintf(stderr,
        "usage:  {0:s} [FUSE, mount, and fg* options] rootDir mountPoint\\n");
    exit(0);
}}
void {0:s}PerrorAndUsage(int status)
{{
    fprintf(stderr, "%s\\n", strerror(status));
    {0:s}Usage();
}}
// Return 0 if OK
void {0:s}ChkDir(const char *dirName)
{{
    struct stat sb;
    int status = 0;
    if (dirName == NULL)
        status = ENOENT;
    else if (dirName[0] == '-')
        status = EPERM;
    else {{
        status = stat(dirName, &sb);
        if ((status == 0) && (!S_ISDIR(sb.st_mode)))
            status = ENOTDIR;
    }}
    if (status)
        {0:s}PerrorAndUsage(status);
}}
int main(int argc, char *argv[])
{{
    int status = 0;
    struct {0:s}Data *myData;

    // Prevent this script from being run by root, because such use is
    // an unacceptable security risk.
    if ((getuid() == 0) || (geteuid() == 0)) {{
        fprintf(stderr, "{0:s} must not be run as root\\n");
        exit(EPERM);
    }}

    // The last two arguments are the paths to the root directory and the
    // mount point respectively.  They must represent valid names for
    // existing directories that the user may access.
    if (argc < 3)
        {0:s}Usage();
    {0:s}ChkDir(argv[argc-2]);
    {0:s}ChkDir(argv[argc-1]);

    // Try to allocate memory for file system's private data.
    myData = calloc(1, sizeof(struct {0:s}Data));
    if (myData == NULL) {{
        perror("main calloc failed");
        abort();
    }}
    // Set up logging; this should be conditional.
    myData->logfile = openLog();

    // The next to the last argument is the root directory.  Save it to
    // private data and then remove it from the argument list passed to fuse,
    // which doesn't expect to see it.
    //
    // XXX Any fg* arguments must also be removed.
    myData->rootdir = realpath(argv[argc-2], NULL);
    argv[argc-2] = argv[argc-1];
    argv[argc-1] = NULL;
    argc--;

    status = fuse_main(argc, argv, &{1:s}OpTable, myData);
    return status;
}}
""".format(pkgName, prefix)

    pathToMain = os.path.join(pathToSrc, 'main.inc')
    with open(pathToMain, 'w') as f:
        f.write(content)

    # package header file -------------------------------------------
    content = """/** {0:s}.h */

#ifndef _{2:s}_H_
#define _{2:s}_H_

// IF INSTRUMENTING CODE ------------------------
#include <pthread.h>        // should be first
// END INSTRUMENTING CODE -----------------------

#include <assert.h>
#include <errno.h>
#include <fuse.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>

// prototypes
int  {1:s}Error(char *);
void {1:s}FullPath(char fpath[PATH_MAX], const char *path);

struct {0:s}Data {{
    // XXX next line should be generated only if logging capability
    FILE *logfile;
    char *rootdir;
}};

#define {2:s}_DATA ((struct {0:s}Data *) fuse_get_context()->private_data)

// BEGIN LOGGING CODE -----------------------------------------------
// This block generated only if including logging capability

void logConn   (struct fuse_conn_info *conn);
void logEntry  (const char *fmt, ...);
void logFI     (struct fuse_file_info *fi);
void logMsg    (const char *fmt, ...);
void logStat   (struct stat *si);
void logstatVFS(struct statvfs *sv);
FILE *openLog  (void);

// END LOGGING CODE -------------------------------------------------

// BEGIN INSTRUMENTATION --------------------------------------------

#define BUCKET_SIZE (64 * 1024)
#define BUCKET_COUNT (60*15)

typedef struct o_ {{
    uint64_t    blockCount;     // number of blocks read or written
    uint32_t    latency;
    uint8_t     opCode;
}} __attribute__((aligned(8))) opData_t;

typedef struct b_ {{
    uint32_t        count;
    pthread_mutex_t mu;
    pthread_cond_t  cond;
    opData_t        ops[BUCKET_SIZE];
}} bucket_t;

extern bucket_t *buckets;   // [BUCKET_COUNT];

opData_t *clockMeIn(struct timespec *tEntry);
void clockMeOut(struct timespec *tEntry, opData_t *mySlot);

// END INSTRUMENTATION ----------------------------------------------
#endif
""".format(pkgName, prefix, ucName)

    headerFile = os.path.join(pathToSrc, "%s.h" % pkgName)
    with open(headerFile, 'w') as f:
        f.write(content)

    # package .c file -----------------------------------------------

    content = """/* {0:s}.c */

#include "fuse_version.h"   // this should be the first header file

#include <ctype.h>
#include <dirent.h>
#include <fcntl.h>
#include <libgen.h>
#include <string.h>

#ifdef HAVE_SYS_XATTR_H
#include <sys/xattr.h>
#endif

#include "{0:s}.h"          // this should be the last header file

///////////////////////////////////////////////////////////
//
// Prototypes for all these functions, and the C-style comments,
// come indirectly from /usr/include/fuse.h

#include "getattr.inc"
#include "readlink.inc"
#include "mknod.inc"
#include "mkdir.inc"
#include "unlink.inc"
#include "rmdir.inc"
#include "symlink.inc"
#include "rename.inc"
#include "link.inc"
#include "chmod.inc"
#include "chown.inc"
#include "truncate.inc"
#include "utime.inc"
#include "open.inc"
#include "read.inc"
#include "write.inc"
#include "statfs.inc"
#include "flush.inc"
#include "release.inc"
#include "fsync.inc"

#ifdef HAVE_SYS_XATTR_H
/** Set extended attributes */
#include "setxattr.inc"
#include "getxattr.inc"
#include "listxattr.inc"
#include "removexattr.inc"
#endif

#include "opendir.inc"
#include "readdir.inc"
#include "releasedir.inc"
#include "fsyncdir.inc"
#include "init.inc"
#include "destroy.inc"
#include "access.inc"
#include "create.inc"
#include "ftruncate.inc"
#include "fgetattr.inc"

#include "optable.inc"
#include "main.inc"
""".format(pkgName)

    pkgCFile = os.path.join(pathToSrc, "%s.c" % pkgName)
    with open(pkgCFile, 'w') as f:
        f.write(content)

    # generate util.c -----------------------------------------------

    content = """/** util.c */

#include "fuse_version.h"   // make me first
#include <stdarg.h>
#include <sys/stat.h>
#include "{0:s}.h"          // this header file should be last

// Log errors to logfile and return -errno to caller.

int {1:s}Error(char *msg)
{{
    int errCode = -errno;
    /** BEGIN 'ONLY IF LOGGING' */
    logMsg("    ERROR %s: %s\\n", msg, strerror(errno));
    /** END 'ONLY IF LOGGING' */
    return errCode;
}}

void {1:s}FullPath(char fpath[PATH_MAX], const char *path)
{{
    strcpy(fpath, {2:s}_DATA->rootdir);
    strncat(fpath, path, PATH_MAX);
    /** BEGIN 'ONLY IF LOGGING' */
    logMsg("  FullPath:  rootdir = \\"%s\\", path = \\"%s\\", fpath = \\"%s\\"\\n",
           {2:s}_DATA->rootdir, path, fpath);
    /** END 'ONLY IF LOGGING' */
}}

/** BEGIN 'ONLY IF LOGGING' SECTION */

FILE *openLog()
{{
    FILE *logfile;

    // Linux appends are guaranteed to be atomic
    logfile = fopen("{0:s}.log", "a");
    if (logfile == NULL) {{
        perror("logfile");
        exit(EXIT_FAILURE);
    }}
    setvbuf(logfile, NULL, _IOLBF, 0);
    return logfile;
}}

void logEntry(const char *format, ...)
{{
    va_list ap;
    va_start(ap, format);

    vfprintf({2:s}_DATA->logfile, format, ap);
}}
void logMsg(const char *format, ...)
{{
    va_list ap;
    va_start(ap, format);

    vfprintf({2:s}_DATA->logfile, format, ap);
}}

static char *msgHeader(char *p, int *maxChar, char *name)
{{
    int n =  snprintf(p, *maxChar, "  %s:\\n", name);
    *maxChar -= n;
    return p + n;
}}

#define MAX_BUFFER (1024 - 1)

// log the name and value of a particular field of the structure s
#define ADD_FIELD(s, field, fmt) \\
  n = snprintf(p, bytesLeft, \\
          "   %-20s = " #fmt "\\n", " " #field "  ", s->field); \\
  bytesLeft -= n;   \\
  p += n;

#define ADD_INT_FIELD(s, field) \\
  n = snprintf(p, bytesLeft, "  %-20s  = %d\\n", "  " #field "  ", (int) s->field); \\
  bytesLeft -= n;   \\
  p += n;

#define ADD_ULONG_FIELD(s, field) \\
  n = snprintf(p, bytesLeft, "  %-20s  = 0x%08lx\\n", "  " #field "  ", (uintptr_t) s->field); \\
  bytesLeft -= n;   \\
  p += n;

#define ADD_LL_FIELD(s, field) \\
  n = snprintf(p, bytesLeft, "  %-20s  = %lld\\n", "  " #field "  ", (long long) s->field); \\
  bytesLeft -= n;   \\
  p += n;

#define ADD_ULL_FIELD(s, field) \\
  n = snprintf(p, bytesLeft, "  %-20s  = 0x%016llx\\n", "  " #field "  ", (unsigned long long) s->field); \\
  bytesLeft -= n;   \\
  p += n;

// from fuse.h
void logContext(struct fuse_context *ctx)
{{
    char buffer[MAX_BUFFER+1];  // allow for null byte
    char *p = buffer;
    int  bytesLeft = MAX_BUFFER;
    int  n;

    p = msgHeader(p, &bytesLeft, "ctx");
    ADD_ULONG_FIELD(ctx, fuse);
    ADD_INT_FIELD(ctx, uid);
    ADD_INT_FIELD(ctx, gid);
    ADD_INT_FIELD(ctx, pid);
    ADD_FIELD(ctx, umask,                   %05o);

    ADD_ULONG_FIELD(ctx, private_data);
    // two fields defined locally
    ADD_ULONG_FIELD(((struct xxxfsData *)ctx->private_data), logfile);
    ADD_FIELD(((struct xxxfsData *)ctx->private_data), rootdir, %s);

    logMsg(buffer);
}}

// from fuse_common.h
void logConn(struct fuse_conn_info *conn)
{{
    char buffer[MAX_BUFFER+1];  // allow for null byte
    char *p = buffer;
    int  bytesLeft = MAX_BUFFER;
    int  n;

    p = msgHeader(p, &bytesLeft, "conn");
    ADD_INT_FIELD(conn, proto_major);
    ADD_INT_FIELD(conn, proto_minor);
    ADD_INT_FIELD(conn, async_read);
    ADD_INT_FIELD(conn, max_write);
    ADD_INT_FIELD(conn, max_readahead);
    ADD_ULONG_FIELD(conn, capable);
    ADD_ULONG_FIELD(conn, want);
    ADD_INT_FIELD(conn, max_background);
    ADD_INT_FIELD(conn, congestion_threshold);

    logMsg(buffer);
}}

// from fuse_common.h
void logFI (struct fuse_file_info *fi)
{{
    char buffer[MAX_BUFFER+1];  // allow for null byte
    char *p = buffer;
    int  bytesLeft = MAX_BUFFER;
    int  n;

    p = msgHeader(p, &bytesLeft, "fi");
    ADD_ULONG_FIELD(fi, flags);
    ADD_ULL_FIELD(fi, fh_old);
    ADD_INT_FIELD(fi, writepage);
    ADD_INT_FIELD(fi, direct_io);
    ADD_INT_FIELD(fi, keep_cache);
    ADD_INT_FIELD(fi, flush);
    ADD_INT_FIELD(fi, nonseekable);
    ADD_INT_FIELD(fi, flock_release);
    ADD_ULL_FIELD(fi, fh);
    ADD_ULL_FIELD(fi, lock_owner);

    logMsg(buffer);
}};

// man struct stat
void logStat(struct stat *ss)
{{
    char buffer[MAX_BUFFER+1];  // allow for null byte
    char *p = buffer;
    int  bytesLeft = MAX_BUFFER;
    int  n;

    p = msgHeader(p, &bytesLeft, "ss");
    ADD_ULL_FIELD(ss, st_dev);
    ADD_ULL_FIELD(ss, st_ino);
    ADD_FIELD(ss, st_mode,      0%o);
    ADD_INT_FIELD(ss, st_nlink);
    ADD_INT_FIELD(ss, st_uid);
    ADD_INT_FIELD(ss, st_gid);
    ADD_ULL_FIELD(ss, st_rdev);
    ADD_ULL_FIELD(ss, st_size);
    ADD_FIELD(ss, st_blksize,   %ld);
    ADD_ULL_FIELD(ss, st_blocks);
    ADD_ULONG_FIELD(ss, st_atime);
    ADD_ULONG_FIELD(ss, st_mtime);
    ADD_ULONG_FIELD(ss, st_ctime);

    logMsg(buffer);
}}

// man struct statvfs
void logStatVFS(struct statvfs *sv)
{{
    char buffer[MAX_BUFFER+1];  // allow for null byte
    char *p = buffer;
    int  bytesLeft = MAX_BUFFER;
    int  n;

    p = msgHeader(p, &bytesLeft, "sv");
    ADD_FIELD(sv, f_bsize,      %ld);
    ADD_FIELD(sv, f_frsize,     %ld);
    ADD_LL_FIELD(sv, f_blocks);
    ADD_LL_FIELD(sv, f_bfree);
    ADD_LL_FIELD(sv, f_bavail);
    ADD_LL_FIELD(sv, f_files);
    ADD_LL_FIELD(sv, f_ffree);
    ADD_LL_FIELD(sv, f_favail);
    ADD_FIELD(sv, f_fsid,       %ld);
    ADD_ULL_FIELD(sv, f_flag);
    ADD_FIELD(sv, f_namemax,    %ld);

    logMsg(buffer);
}}

/** END 'ONLY IF LOGGING' SECTION */

/** BEGIN INSTRUMENTATION */

// calloc BUCKET_COUNT of these
bucket_t *buckets;

opData_t *clockMeIn(struct timespec *tEntry)
{{
    int status = clock_gettime(CLOCK_MONOTONIC, tEntry);
    assert(status == 0);
    int bktNdx = ((long) tEntry->tv_sec) % BUCKET_COUNT;
    bucket_t *myBucket = &buckets[bktNdx];
    // LOCK
    int myCount = myBucket->count++;
    // UNLOCK
    return &myBucket->ops[myCount];
}}

#define BILLION (1000000000LL)
void clockMeOut(struct timespec *tEntry, opData_t *mySlot)
{{
    struct timespec tExit;
    long inSec  = tEntry->tv_sec;
    long inNsec = tEntry->tv_nsec;
    int status = clock_gettime(CLOCK_MONOTONIC, &tExit);
    assert(status == 0);
    long outSec  = tExit.tv_sec;
    long outNsec = tExit.tv_nsec;
    if (inNsec > outNsec) {{
        outNsec += BILLION;
        outSec  --;
    }}
    long latency = outNsec - inNsec;
    assert(outSec >= inSec);
    assert(latency < BILLION);
    mySlot->latency = latency;
}}
/** END INSTRUMENTATION */
""".format(pkgName, prefix, ucName)

    utilCFile = os.path.join(pathToSrc, "util.c")
    with open(utilCFile, 'w') as f:
        f.write(content)

    # generate .inc files -------------------------------------------

    # optable.inc -----------------------------------------
    content = """/** optable.inc */

struct fuse_operations {0:s}OpTable = {{
    .getattr      = {0:s}getattr,
    .readlink     = {0:s}readlink,
    .getdir       = NULL,
    .mknod        = {0:s}mknod,
    .mkdir        = {0:s}mkdir,
    .unlink       = {0:s}unlink,
    .rmdir        = {0:s}rmdir,
    .symlink      = {0:s}symlink,
    .rename       = {0:s}rename,
    .link         = {0:s}link,
    .chmod        = {0:s}chmod,
    .chown        = {0:s}chown,
    .truncate     = {0:s}truncate,
    .utime        = {0:s}utime,
    .open         = {0:s}open,
    .read         = {0:s}read,
    .write        = {0:s}write,
    .statfs       = {0:s}statfs,
    .flush        = {0:s}flush,
    .release      = {0:s}release,
    .fsync        = {0:s}fsync,

#ifdef HAVE_SYS_XATTR_H
    .setxattr     = {0:s}setxattr,
    .getxattr     = {0:s}getxattr,
    .listxattr    = {0:s}listxattr,
    .removexattr  = {0:s}removexattr,
#endif

    .opendir      = {0:s}opendir,
    .readdir      = {0:s}readdir,
    .releasedir   = {0:s}releasedir,
    .fsyncdir     = {0:s}fsyncdir,
    .init         = {0:s}init,
    .destroy      = {0:s}destroy,
    .access       = {0:s}access,
    .create       = {0:s}create,
    .ftruncate    = {0:s}ftruncate,
    .fgetattr     = {0:s}fgetattr
}};
""".format(prefix)
    opTableFile = os.path.join(pathToPkg, os.path.join('src', 'optable.inc'))
    with open(opTableFile, 'w') as f:
        f.write(content)

    # generate op .inc files ------------------------------
    opAttrs = setOpAttrs()
    # mkSrcDir(args, opAttrs)

    srcDir = os.path.join(pathToPkg, 'src')
    makedir_p(srcDir, 0o755)

    m = FuseFunc.getFuncMap(prefix)

    # XXX does not catch 'main'
    for name in OP_NAMES:
        attrs = opAttrs[name]
        if attrs & DEPRECATED:
            continue
        ff = m[name]    # FuseFunc for this name
        pathToInc = os.path.join(srcDir, "%s.inc" % name)
        ss = []
        ss.append("/** %s.inc */\n" % (name))
        if attrs & CHK_DEF_XATTR:
            ss.append("#ifdef HAVE_SYS_XATTR_H")

        # -- first line, LBRACE -----------------------
        ss.append("%s\n{" % ff.firstLine())

        # -- variable declarations --------------------
        if attrs & RETURNS_STATUS:
            ss.append('    int status = 0;')
        if attrs & SYSCALL_RET_FD:
            ss.append('    int fd;')
        if attrs & (FULL_PATH | DOUBLE_FULL_PATH):
            ss.append('    char fpath[PATH_MAX];')
        if attrs & DOUBLE_FULL_PATH:
            ss.append('    char fnewpath[PATH_MAX];')
        if attrs & HAS_LINK_FILE:
            ss.append('    char flink[PATH_MAX];')

        if name in ['opendir', 'readdir']:
            ss.append('    DIR *dp;')
            if name=='readdir':
                ss.append('    struct dirent *entry;')
        elif name == 'listxattr':
            ss.append('    char *ptr;')

        ss.append("")

        # -- log on entry -----------------------------
        if name == 'init':
            ss.append("    logEntry(\"\\n%sinit()\\n\");" % prefix)
            ss.append('    logConn(conn);')
            ss.append('    logContext(fuse_get_context());')
        elif attrs & LOGGING_ENTRY:

            if attrs & DOUBLE_FULL_PATH:
                part0 = "\"\\n%s%s" % (prefix, name)
                part1 = '(path=\\"%s\\", newpath=\\"%s\\")\\n",'
                s = "    logEntry(" + part0 + part1
                ss.append(s)
                ss.append("            path, newpath);")
            else:
                logE = ['    logEntry(\"\\n%s%s(' % (prefix, name) ]
                for ndx, param in enumerate(ff.params):
                    if ndx > 0:
                        logE.append(', ')
                    pName = param[1]
                    if pName == 'size':
                        if name in ['read', 'write', ]:
                            pat = '%lld'
                        else:
                            pat = '%d'
                    elif pName == 'value':
                        if name in ['getxattr',]:
                            pat = '0x%08x'
                        else:
                            pat = '\\"%s\\"'
                    elif pName in LOG_ENTRY_PAT_MAP:
                        pat  = LOG_ENTRY_PAT_MAP[pName]
                    else:
                        pat = 'UNKNOWN PAT FOR \'%s\'' % pName
                    logE.append( '%s=%s' % (pName, pat))
                logE.append(")\\n\",")
                ss.append( ''.join(logE))

                # now add a parameter list on the next line
                logEP = ['             ']
                for ndx, param in enumerate(ff.params):
                    if ndx > 0:
                        logEP.append(', ')
                    pName = param[1]
                    logEP.append(pName)
                logEP.append(');')
                ss.append(''.join(logEP))

        if name == 'readdir':
            ss.append('    dp = (DIR *) (uintptr_t) fi->fh;')

        if name != 'opendir' and name != 'readdir' and attrs & LOGGING_FI and not attrs & SET_FH_FROM_FD:
            ss.append('    logFI(fi);')

        # -- set up absolute paths ------------------------
        if attrs & FULL_PATH:
            ss.append("    %sFullPath(fpath, path);" % prefix)
        if attrs & DOUBLE_FULL_PATH:
            ss.append("    %sFullPath(fnewpath, newpath);" % prefix)
        if attrs & HAS_LINK_FILE:
            ss.append("    %sFullPath(flink, link);" % prefix)
        ss.append("")

        # -- call FUSE ------------------------------------

        sysCall = OP_CALL_MAP[name][0]
        if sysCall == '':
            if name != 'init':
                ss.append("    // CURRENTLY A NO-OP\n")
        else:
            if name == 'fsync':
                ss.append(
"""    // freebsd
#ifdef HAVE_FDATASYNC
    if (datasync)
        status = fdatasync(fi->fh);
    else
#endif
        status = fsync(fi->fh);""")

            elif name == 'mknod':
                # in python format specs {} must be doubled :-(
                ss.append(

"""    // ATTRIBUTION
    if (S_ISREG(mode)) {{
        status = open(fpath, O_CREAT | O_EXCL | O_WRONLY, mode);
        if (status < 0)
            status = {0:s}Error(\"{0:s}mknod open\");
        else {{
            status = close(status);
            if (status < 0)
                status = {0:s}Error(\"{0:s}mknod close\");
        }}
    }} else if (S_ISFIFO(mode)) {{
        status = mkfifo(fpath, mode);
        if (status < 0)
            status = {0:s}Error(\"{0:s}mknod mkfifo\");
    }} else {{
        status = mknod(fpath, mode, dev);
        if (status < 0)
            status = {0:s}Error(\"{0:s}mknod mknod\");
    }}""".format(prefix) )

            elif name == 'open':
                ss.append("    fd = %s(fpath, fi->flags);" % sysCall)
            elif name == 'readdir':
                content = """
    entry = readdir(dp);
    if (entry == 0) {{
        status = {0:s}Error("{0:s}readdir readdir");
        return status;
    }}
    do {{
        logMsg("calling filler(%s)\\n", entry->d_name);
        if (filler(buf, entry->d_name, NULL, 0) != 0) {{
            logMsg("    ERROR {0:s}readdir filler:  buffer full");
            return -ENOMEM;
        }}
    }} while ((entry = readdir(dp)) != NULL);
""".format(prefix)
                ss.append(content)

            elif name == 'readlink':
                ss.append("    status = readlink(fpath, link, size - 1);")
            elif name == 'releasedir':
                ss.append("    status = closedir((DIR *) (uintptr_t) fi->fh);")
            elif attrs & HAS_LINK_FILE:
                ss.append("    status = %s(path, flink);" % sysCall)
            elif attrs & DOUBLE_FULL_PATH:
                ss.append("    status = %s(fpath, fnewpath);" % sysCall)
            elif attrs & (FULL_PATH | LOGGING_FI):
                if attrs & SYSCALL_RET_FD:
                    ss.append("    fd = %s(fpath%s);" % (
                        sysCall, ff.otherArgs()))
                else:
                    if attrs & SYSCALL_FI_PARAM1:
                        if name == 'fgetattr':
                            ss.append('    // FreeBSD special case; ATTRIBUTION')
                            ss.append('    if (!strcmp(path, "/")) {')
                            ss.append('        char fpath[PATH_MAX];')
                            ss.append("        %sFullPath(fpath, path);" % (
                                prefix))
                            ss.append("        status = lstat(fpath%s);" % (
                                ff.otherArgs()))
                            ss.append('        if (status < 0)')
                            ss.append("            status = %sError(\"%sfgetattr lstat\");" % (prefix, prefix))
                            ss.append('    } else {')
                            ss.append("        status = %s(fi->fh%s);" % (
                                sysCall, ff.otherArgs()))
                            ss.append('        if (status < 0)')
                            ss.append("            status = %sError(\"%sfgetattr fstat\");" % (prefix, prefix))
                            ss.append('    }')
                        elif name == 'opendir':
                            ss.append('    dp = opendir(fpath);')
                        else:
                            ss.append("    status = %s(fi->fh%s);" % (
                                sysCall, ff.otherArgs()))
                    else:
                        ss.append("    status = %s(fpath%s);" % (
                            (sysCall, ff.otherArgs())))

        # -- check for error status -----------------------
        if name == 'opendir':
            ss.append('    if (dp == NULL)')
            ss.append("        status = %sError(\"%s%s %s\");" % (
                prefix, prefix, name, sysCall))
        elif name != 'fgetattr' and attrs & CHECK_ERR_AND_FLIP:
            if attrs & SYSCALL_RET_FD:
                ss.append("    if (fd < 0)")
            else:
                ss.append("    if (status < 0)")
            ss.append("        status = %sError(\"%s %s\");\n" % (
                prefix, prefix + name, sysCall))
            if name == 'readlink':
                ss.append('    else {')
                ss.append('        link[status] = \'\\0\';')
                ss.append('        status = 0;')
                ss.append('    }')
        if name in ['getxattr',]:
            ss.append('    else')
            ss.append('        logMsg("    value=\\"%s\\"\\n", value);')

        if name == 'listxattr':
            ss.append(
              '    logMsg("    returned attributes (length %d):\\n", status);')
            ss.append(
              '    for (ptr = list; ptr < list + status; ptr += strlen(ptr)+1)')
            ss.append('        logMsg("    \\"%s\\"\\n", ptr);')

        # -- logging stat -----------------------------
        if attrs & LOGGING_STAT:
            ss.append("    logStat(%s);\n"    % ff.params[1][1])
        elif attrs & LOGGING_STATVFS:
            ss.append("    logStatVFS(%s);\n" % ff.params[1][1])

        if attrs & SET_FH_FROM_FD:
            ss.append('    fi->fh = fd;')
            ss.append('    logFI(fi);')
        elif name=='opendir':
            ss.append('    fi->fh = (intptr_t) dp;')
            ss.append('    logFI(fi);')
        elif name=='readdir':
            ss.append('    logFI(fi);')

        # -- return -----------------------------------
        if attrs & RETURNS_STATUS:
            ss.append("    return status;")
        elif name == 'init':
            ss.append("    return %s_DATA;" % ucName)
        ss.append("}")
        if attrs & CHK_DEF_XATTR:
            ss.append("#endif")

        out = "\n".join(ss) + "\n"
        with open(pathToInc, 'w') as f:
            f.write(out)
def main():
    # program defaults ----------------------------------------------
    myDate   = "%04d-%02d-%02d" % time.gmtime()[:3]

    # parse the command line ----------------------------------------

    DESC = 'generate a minimal FUSE (file system in user space) package'
    parser = ArgumentParser(description=DESC)

    parser.add_argument('-A', '--acPrereq', default='2.69',
        help='prerequisite autoconfig version number')

    parser.add_argument('-D', '--myDate', default=myDate,
        help='date in YYYY-MM-DD format')

    parser.add_argument('-E', '--emailAddr', default='jddixon at gmail dot com',
        help='contact email address')

    parser.add_argument('-f', '--force', action='store_true',
        help='if utility already exists, overwrite it')

    parser.add_argument('-j', '--justShow', action='store_true',
        help='show options and exit')

    parser.add_argument('-P', '--pkgName',
        help='utility package name')

    parser.add_argument('-T', '--testing', action='store_true',
        help='this is a test run')

    parser.add_argument('-v', '--verbose', action='store_true',
        help='be chatty')

    parser.add_argument('-V', '--myVersion', default = '0.0.0',
        help="version in X.Y.Z format")

    args = parser.parse_args()

    # sanity checks -------------------------------------------------
    checkDate(args.myDate)
    checkPkgName(args.pkgName)
    checkVersion(args.myVersion)

    # fixups --------------------------------------------------------
    args.lcName = args.pkgName.lower()
    args.ucName = args.pkgName.upper()

    if args.testing:
        args.pathToPkg = os.path.join('tmp', args.pkgName)
    else:
        args.pathToPkg = os.path.join('/home/jdd/dev/c', args.pkgName)

    # complete setup ------------------------------------------------
    appName = 'fuseGen %s' % __version__

    # maybe show options and such -----------------------------------
    if args.verbose or args.justShow:
        print ("%s %s" % (appName, __version_date__))

    if args.verbose or args.justShow:
        print('acPrereq             = ' + str(args.acPrereq))
        print('emailAddr            = ' + str(args.emailAddr))
        print('force                = ' + str(args.force))
        print('myDate               = ' + str(args.myDate))
        print('myVersion            = ' + str(args.myVersion))
        print('pathToPkg            = ' + str(args.pathToPkg))
        print('pkgName              = ' + str(args.pkgName))
        print('  lcName             = ' + str(args.lcName))
        print('  ucName             = ' + str(args.ucName))
        print('testing              = ' + str(args.testing))
        print('verbose              = ' + str(args.verbose))

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------
    makeFusePkg(args)

if __name__ == '__main__':
    main()

