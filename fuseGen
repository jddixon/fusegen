#!/usr/bin/python3
#
# ~/dev/py/fusegen/fuseGen

import errno, os, sys, shutil, time
from argparse  import ArgumentParser
from fusegen   import *

# attributes of fuse operations

RETURNS_STATUS      = 0x00001     # check
DEPRECATED          = 0x00002     # 'D'
SIMPLE_ERROR        = 0x00004     # 'e'
COMPLEX_ERROR       = 0x00008     # 'ee'
FULL_PATH           = 0x00010     # 'f'
DOUBLE_FULL_PATH    = 0x00020     # 'ff'
LOGGING_ENTRY       = 0x00040     # 'L'
COMPLEX_LOGGING     = 0x00080     # 'LL'
IFDEF_XATTR         = 0x00100     # 'X'
LOGGING_STAT        = 0x00200
LOGGING_STATVFS     = 0x00400
HAS_LINK_FILE       = 0x00800
LOGGING_FI          = 0x01000
SYSCALL_RET_FD      = 0x02000
SET_FH_FROM_FD        = 0x04000
SYSCALL_FI_PARAM1   = 0x08000

def setOpAttrs():
    """
    Return a map from fuse op names to attributes
    """
    opAttrs = {}
    for name in OP_NAMES:
        attrs = 0
        if name in ['symlink',]:
            attrs |= HAS_LINK_FILE

        if name == 'getdir':
            attrs |= DEPRECATED

        if name != 'init' and name != 'destroy':
            attrs |= RETURNS_STATUS

        if name in ['rename','link',]:
            attrs |= DOUBLE_FULL_PATH

        if name not in ['symlink',
                        'read', 'write', 'flush', 'release', 'fsync',
                        'readdir', 'releasedir','fsyncdir', 'init',
                        'destroy', 'ftruncate', 'fgetattr']:
            attrs |= FULL_PATH

        if name in ['mknod', 'readdir', ]:
            attrs |= COMPLEX_ERROR
        elif name in ['flush', 'releasedir', 'fsyncdir', 'init', 'destroy',]:
            pass
        else:
            attrs |= SIMPLE_ERROR

        if name in ['setxattr', 'getxattr', 'listxattr', 'removexattr',]:
            attrs |= IFDEF_XATTR

        # XXX NOWHERE USED
        if name in ['readlink', 'mknod', 'write',
                    'getxattr', 'listxattr', 'readdir',]:
            attrs |= COMPLEX_LOGGING

        # XXX THIS USED TO BE 'else'
        attrs |= LOGGING_ENTRY

        if name in ['create', 'fgetattr', 'flush', 'fsync', 'fsyncdir', 
                'ftruncate',
                'opendir', 'open', 'readdir', 'read', 'releasedir',
                'release', 'write',]:
            attrs |= LOGGING_FI

        if name in ['create', 'open',  ]:
            attrs |= SET_FH_FROM_FD

        if name in ['fgetattr', 'fsync', 'opendir', 'read', 'releasedir', 'release', 'ftruncate', 'write']:
            attrs |= SYSCALL_FI_PARAM1

        if name in ['getattr', 'fgetattr',]:
            attrs |= LOGGING_STAT
        elif name == 'statfs':
            attrs |= LOGGING_STATVFS

        if name in ['create', 'open',]:
            attrs |= SYSCALL_RET_FD

        opAttrs[name] = attrs

    return opAttrs

def makedir_p(path, mode):
    # XXX SLOPPY: doesn't handle case where mode is wrong
    # XXX MISLEADING: the name suggests it creates missing subdirs
    try:
        os.mkdir(path, mode)
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise e
        pass

def makeFusePkg(args):
    force           = args.force
    lcName          = args.lcName
    myDate          = args.myDate
    myVersion       = args.myVersion
    pathToPkg       = args.pathToPkg    # target package directory
    pkgName         = args.pkgName
    prefix          = pkgName + '_'     # XXX FORCES UNDERSCORE
    testing         = args.testing
    ucName          = args.ucName
    verbose         = args.verbose

    # if -force and pathToPkg exists, delete it ---------------------
    if force and os.path.exists(pathToPkg):
        shutil.rmtree(pathToPkg)

    # create directories --------------------------------------------
    os.mkdir(pathToPkg, 0o755)

    makeFileSubDirs = ['doc', 'examples', 'man', 'scripts', 'src', 'tests',]
    otherSubDirs    = ['automAte.cache', 'ghpDoc', 'm4', ]
    subDirs         = makeFileSubDirs + otherSubDirs
    for dir in subDirs:
        pathToSubDir = os.path.join(pathToPkg, dir)
        makedir_p(pathToSubDir, 0o755)

    # write CHANGES -------------------------------------------------
    chgFile = os.path.join(pathToPkg, 'CHANGES')
    with open(chgFile, 'w', 0o644) as f:
        f.write("~/dev/c/%s/CHANGES\n\n" % pkgName)
        f.write("v%s\n" % myVersion)
        f.write("    %s\n" % myDate)
        f.write("        *\n")

    # write configure.ac --------------------------------------------
    todoFile = os.path.join(pathToPkg, 'configure.ac')
    with open(todoFile, 'w', 0o644) as f:
        f.write("~/dev/c/%s/TODO\n\n" % pkgName)
        f.write("%s\n" % myDate)
        f.write("    *\n")

    # write TODO ----------------------------------------------------
    todoFile = os.path.join(pathToPkg, 'TODO')
    with open(todoFile, 'w', 0o644) as f:
        f.write("~/dev/c/%s/TODO\n\n" % pkgName)
        f.write("%s\n" % myDate)
        f.write("    *\n")

    opAttrs = setOpAttrs()
    # mkSrcDir(args, opAttrs)

    srcDir = os.path.join(pathToPkg, 'src')
    makedir_p(srcDir, 0o755)

    m = FuseFunc.getFuncMap(prefix)

    # XXX does not catch 'main'
    for name in OP_NAMES:
        attrs = opAttrs[name]
        if attrs & DEPRECATED:
            continue
        ff = m[name]    # FuseFunc for this name
        pathToInc = os.path.join(srcDir, "%s.inc" % name)
        ss = []
        ss.append("/** %s.inc */\n" % (name))
        if attrs & IFDEF_XATTR:
            ss.append("#ifdef HAVE_SYS_XATTR_H")

        # -- first line, LBRACE -----------------------
        ss.append("%s\n{" % ff.firstLine())

        # -- variable declarations --------------------
        if attrs & RETURNS_STATUS:
            ss.append('    int status = 0;')   # XXX status
        if attrs & SYSCALL_RET_FD:
            ss.append('    int fd;')
        if attrs & (FULL_PATH | DOUBLE_FULL_PATH):
            ss.append('    char fpath[PATH_MAX];')
        if attrs & DOUBLE_FULL_PATH:
            ss.append('    char fnewpath[PATH_MAX];')
        if attrs & HAS_LINK_FILE:
            ss.append('    char flink[PATH_MAX];')

        if name in ['opendir', 'readdir']:
            ss.append('    DIR *dp;')
            if name=='readdir':
                ss.append('    struct dirent *de;')
        elif name == 'listxattr':
            ss.append('    char *ptr;')

        ss.append("")

        # -- log on entry -----------------------------
        if name == 'init':
            ss.append("    logEntry(\"\\n%sinit()\\n\");" % prefix)
            ss.append('    logConn(conn);')
            ss.append('    logContext(fuse_get_context());')
        elif attrs & LOGGING_ENTRY:

            if attrs & DOUBLE_FULL_PATH:
                part0 = "\"\\n%s%s" % (prefix, name)
                part1 = '(path=\\"%s\\", newpath=\\"%s\\")\\n",'
                s = "    logEntry(" + part0 + part1
                ss.append(s)
                ss.append("            path, newpath);")
            else:
                logE = ['    logEntry(\"\\n%s%s(' % (prefix, name) ]
                for ndx, param in enumerate(ff.params):
                    if ndx > 0:
                        logE.append(', ')
                    pName = param[1]
                    if pName == 'size':
                        if name in ['read', 'write', ]:
                            pat = '%lld'
                        else:
                            pat = '%d'
                    elif pName == 'value':
                        if name in ['getxattr',]:
                            pat = '0x%08x'
                        else:
                            pat = '\\"%s\\"'
                    elif pName in LOG_ENTRY_PAT_MAP:
                        pat  = LOG_ENTRY_PAT_MAP[pName]
                    else:
                        pat = 'UNKNOWN PAT FOR \'%s\'' % pName
                    logE.append( '%s=%s' % (pName, pat))
                logE.append(")\\n\",")
                ss.append( ''.join(logE))

                # now add a parameter list on the next line
                logEP = ['            ']
                for ndx, param in enumerate(ff.params):
                    if ndx > 0:
                        logEP.append(', ')
                    pName = param[1]
                    logEP.append(pName)
                logEP.append(');')
                ss.append(''.join(logEP))
        
        if name != 'opendir' and attrs & LOGGING_FI and not attrs & SET_FH_FROM_FD:
            ss.append('    log_fi(fi);')

        # -- set up absolute paths ------------------------
        if attrs & FULL_PATH:
            ss.append("    %sfullpath(fpath, path);" % prefix)
        if attrs & DOUBLE_FULL_PATH:
            ss.append("    %sfullpath(fnewpath, newpath);" % prefix)
        if attrs & HAS_LINK_FILE:
            ss.append("    %sfullpath(flink, link);" % prefix)
        ss.append("")

        # -- call FUSE ------------------------------------

        sysCall = OP_CALL_MAP[name][0]
        if sysCall == '':
            if name != 'init':
                ss.append("    // CURRENTLY A NO-OP\n")
        else:
            if name == 'fsync':
                ss.append('    // freebsd')
                ss.append('#ifdef HAVE_FDATASYNC')
                ss.append('    if (datasync)')
                ss.append('        status = fdatasync(fi->fh);')
                ss.append('    else')
                ss.append('#endif')
                ss.append('        status = fsync(fi->fh);')

            elif name == 'open':
                ss.append("    fd = %s(fpath, fi->flags);" % sysCall)
            elif name == 'readlink':
                ss.append("    status = readlink(fpath, link, size - 1);")
            elif name == 'releasedir':
                ss.append("    // ANOMALY: status not handled")
                ss.append("    closedir((DIR *) (uintptr_t) fi->fh);")
            # catches release XXX SHOULD CATCH ftruncate *** DROPPED ***
#            elif len(ff.params) == 2 and ff.params[1][1] == 'fi':
#                # DEBUG
#                print("2 PARAMS: name=%s, prefix=%s" % (name, prefix))
#                # END
#                # a HACK
#                if name != 'flush':
#                    ss.append("    status = %s(fi->fh);" % sysCall)

            elif attrs & HAS_LINK_FILE:
                ss.append("    status = %s(path, flink);" % sysCall)
            elif attrs & DOUBLE_FULL_PATH:
                ss.append("    status = %s(fpath, fnewpath);" % sysCall)
            elif attrs & (FULL_PATH | LOGGING_FI):
                if attrs & SYSCALL_RET_FD:
                    ss.append("    fd = %s(fpath%s);" % ( 
                        sysCall, ff.otherArgs()))
                else:
                    if attrs & SYSCALL_FI_PARAM1:
                        if name == 'fgetattr':
                            ss.append('    // FreeBSD special case; ATTRIBUTION')
                            ss.append('    if (!strcmp(path, "/")) {')
                            ss.append('        char fpath[PATH_MAX];')
                            ss.append("        %sfullpath(fpath, path);" % (
                                prefix))
                            ss.append("        status = lstat(fpath%s);" % (
                                ff.otherArgs()))
                            ss.append('        if (status < 0)')
                            ss.append("            status = %serror(\"%sfgetattr lstat\");" % (prefix, prefix))
                            ss.append('    } else {')
                            ss.append("        status = %s(fi->fh%s);" % (
                                sysCall, ff.otherArgs()))
                            ss.append('        if (status < 0)')
                            ss.append("            status = %serror(\"%sfgetattr fstat\");" % (prefix, prefix))
                            ss.append('    }')
                        elif name == 'opendir':
                            ss.append('    dp = opendir(fpath);')
                        else:
                            ss.append("    status = %s(fi->fh%s);" % (
                                sysCall, ff.otherArgs()))
                    else:
                        ss.append("    status = %s(fpath%s);" % ( 
                            (sysCall, ff.otherArgs())))
                    
        # -- check for error status -----------------------
        if name == 'opendir':
            ss.append('    if (dp == NULL)')
            ss.append("        status = %serror(\"%s%s %s\");" % (
                prefix, prefix, name, sysCall))
        elif name != 'fgetattr' and attrs & SIMPLE_ERROR:
            if attrs & SYSCALL_RET_FD:
                ss.append("    if (fd < 0)")
            else:
                ss.append("    if (status < 0)")
            ss.append("        status = %serror(\"%s %s\");\n" % (
                prefix, prefix + name, sysCall))
            if name == 'readlink':
                ss.append('    else {')
                ss.append('        link[status] = \'\\0\';')
                ss.append('        status = 0;')
                ss.append('    }')
        if name in ['getxattr',]:
            ss.append('    else')
            ss.append('        logMsg("    value=\\"%s\\"\\n", value);')

        if name == 'listxattr':
            ss.append(
              '    logMsg("    returned attributes (length %d):\\n", status);')
            ss.append(
              '    for (ptr = list; ptr < list + status; ptr += strlen(ptr)+1)')
            ss.append('        logMsg("    \\"%s\\"\\n", ptr);')

        # -- logging stat -----------------------------
        if attrs & LOGGING_STAT:
            ss.append("    logStat(%s);\n" % ff.params[1][1])
        elif attrs & LOGGING_STATVFS:
            ss.append("    logStatVFS(%s);\n" % ff.params[1][1])

        if attrs & SET_FH_FROM_FD:
            ss.append('    fi->fh = fd;')
            ss.append('    log_fi(fi);')
        elif name=='opendir':
            ss.append('    fi->fh = (intptr_t) dp;')
            ss.append('    log_fi(fi);')

        # -- return -----------------------------------
        if attrs & RETURNS_STATUS:
            ss.append("    return status;")
        elif name == 'init':
            ss.append("    return %s_DATA;" % ucName)
        ss.append("}")
        if attrs & IFDEF_XATTR:
            ss.append("#endif")     # GEEP

        out = "\n".join(ss) + "\n"
        with open(pathToInc, 'w') as f:
            f.write(out)
def main():
    """
    Expect a command like
        fuseGen [options]

    """

    # program defaults ----------------------------------------------
    myDate   = "%04d-%02d-%02d" % time.gmtime()[:3]

    # parse the command line ----------------------------------------

    DESC = 'generate a minimal FUSE (file system in user space) package'
    parser = ArgumentParser(description=DESC)

    parser.add_argument('-D', '--myDate', default=myDate,
        help='date in YYYY-MM-DD format')

    parser.add_argument('-f', '--force', action='store_true',
        help='if utility already exists, overwrite it')

    parser.add_argument('-j', '--justShow', action='store_true',
        help='show options and exit')

    parser.add_argument('-P', '--pkgName',
        help='utility package name')

    parser.add_argument('-T', '--testing', action='store_true',
        help='this is a test run')

    parser.add_argument('-v', '--verbose', action='store_true',
        help='be chatty')

    parser.add_argument('-V', '--myVersion', default = '0.0.0',
        help="version in X.Y.Z format")

    args = parser.parse_args()

    # sanity checks -------------------------------------------------
    checkDate(args.myDate)
    checkPkgName(args.pkgName)
    checkVersion(args.myVersion)

    # fixups --------------------------------------------------------
    args.lcName = args.pkgName.lower()
    args.ucName = args.pkgName.upper()

    if args.testing:
        args.pathToPkg = os.path.join('tmp', args.pkgName)
    else:
        args.pathToPkg = os.path.join('/home/jdd/dev/c', args.pkgName)

    # complete setup ------------------------------------------------
    appName = 'fuseGen %s' % __version__

    # maybe show options and such -----------------------------------
    if args.verbose or args.justShow:
        print ("%s %s" % (appName, __version_date__))

    if args.verbose or args.justShow:
        print('force                = ' + str(args.force))
        print('myDate               = ' + str(args.myDate))
        print('myVersion            = ' + str(args.myVersion))
        print('pathToPkg            = ' + str(args.pathToPkg))
        print('pkgName              = ' + str(args.pkgName))
        print('  lcName             = ' + str(args.lcName))
        print('  ucName             = ' + str(args.ucName))
        print('testing              = ' + str(args.testing))
        print('verbose              = ' + str(args.verbose))

    if args.justShow:
        sys.exit(0)

    # do what's required --------------------------------------------
    makeFusePkg(args)


if __name__ == '__main__':
    main()

